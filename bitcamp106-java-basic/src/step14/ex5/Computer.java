package step14.ex5;

public interface Computer {
    // 초창기 컴퓨터는 계산하는 기능이 중요했다.
    void compute();
    
    //void touch(); // 추가하는 순간 기존 클래스들에서 컴파일 오류발생
    
    //문제점
    // => 규칙을 변경하면 , 그 규칙에 따라 만든 모든클래스를 변경해야 한다.
//     => 내가 만든 규칙에 따라 내가 클래스를 만들었다면 내가 변경하면 되지만
//    내가 만든규칙을 다른 많은 개발자들이 가져가서 클래스를 만들어 사용하고 있따면
//    내가 쉽게 규칙을 변경할 상황이 아닌것이다.
    // 내가  규칙 즉 인터페이스의 매서드 변경하거나 제거, 추가하는순간
    // 이인터페이스를 구현한 모든클래스들에서 컴파일 오류가 발생하게 된다.
    // 하지만 , 계속 옛날 규칙을 가져갈순 없고,
//     새프로젝트에는 변경된 규칙으로 클래스를 만들고 싶어한다.
//    새 규칙을 새 인터페이스로 정의할순 있지만,
    // 그렇게하면 기존의 진행한 모든 프로젝트들과 호환되지 않는 문제가 발생한다
    //
    // 기존 규칙을 변경하되, 기존 구현체에는 영향을 끼치고 싶지 않을 떄
    // 바로 다음 문법을 사용하라!!!
    // 디폴트 메서드!! - JDK9에서 추가한 문법이다.
    default void touch() {
        //구현할 코드 있으면 작성하고 없으면 빈 채로 내버려 둔다.
    }
    // 위에 touch()라는 새 규칙을 추가하더라도
    // 기존의 작성한 FirstComputer, SecondComputer, Third Computer 클래스 모두
//     컴파일 오류가 발생하지 않는다
    // 왜 ? 구현된 메서드 이기때문이다
    
//    가능한 일반 클래스의 메서드처럼 사용하지 말아라
//     새규칙을 추가하는 의미로 default 메서드를 사용해야지

}

